%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  ANPR

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{PyANPR}
\hyphenation{re-co-nhe-ci-men-to a-tu-al-men-te}
\label{cap:anpr}

  Nesse capítulo serão abordados os principais conceitos sobre um sistema de Reconhecimento Automático de Números de Placas (\textit{Automatic Number Plate Recognition} - ANPR). Nesse trabalho será adotado o acrônimo do termo em inglês ANPR. Atualmente, ANPR se tornou a principal técnica para muitos sistemas de transporte automatizado, como monitoramento de tráfego em estradas, pagamento automático de pedágios e controle de acesso a pontes e estacionamentos. Esse tipo de sistema consiste em, a partir de uma imagem de um carro, localizar a placa e identificar os caracteres presentes nesta. Com base no reconhecimento dos caracteres presentes na placa, é possível identificar o carro e levantar informações sobre o mesmo automaticamente.

    Sistemas ANPR também são conhecidos como: \textit{Automatic licence plate recognition} (ALPR), \textit{Automatic vehicle identification} (AVI), \textit{Car plate recognition} (CPR), \textit{Licence plate recognition} (LPR) e \textit{Lecture Automatique de Plaques d'Immatriculation} (LAPI). A idéia de um sistema ANPR foi criado em 1976, pelo Departamento de Desenvolvimento Científico da Polícia no Reino Unido, com o objetivo de identificar carros roubados. O primeiro protótipo desenvolvido ficou pronto em 1979 e foi desenvolvido pela empresa Britânica EMI \textit{Electronics}. Esse sistema começou a ser testado na rodovia A! e no Túnel Dartford, ambos na Inglaterra. Somente em 1981 ocorreu a identificação de um carro roubado, seguido da prisão do delinquente, através da utilização deste sistema.

    Há algum tempo atrás, a identificação de veículos era um trabalho completamente manual, porém, com o crescimento do tráfego de veículos nas rodovias, a tarefa de identificação manual de veículos se tornou inviável. Com a evolução dos componentes eletrônicos, foi criado um sistema AVI, onde, o código do veículo era armazenado em um \textit{transponder} que era instalado em cada veículo. Quando o veículo passava por alguns pontos de controle da rodovia, unidades de leitura identificavam a sua presença e realizavam a leitura do seu código, presente no \textit{transponder}. Muitos sistemas AVI eram equipados com um sistema de captura de vídeo, aumentando o seu custo. Com o aumento considerável de veículos, a produção e manutenção em larga escala desses sistemas passaram a se tornar extremamente custosa. Com a evolução das técnicas de visão computacional, tornou-se possível a identificação de veículos pela leitura de suas placas através de câmeras de monitoramento, diminuindo o custo para implantação desse tipo de sistema.
     
    Na aplicação PyANPR, desenvolvida nesse trabalho, existem três etapas entre a inclusão da imagem de um carro até a extração do caractere. A primeira consiste na localização da placa. A segunda consiste num pré-processamento da placa, para binarizar a imagem e remover ruídos. E a terceira etapa consiste em aplicar uma função de OCR a fim de identificar os caracteres da placa. Cada uma das etapas serão descritas nas seguintes seções.

\section{Localização da Placa}
  O processo de localização é a etapa mais importante e vulnerável de todo o ANPR. Existem duas suposições básicas em sistemas ANPR \cite{Shapiro2006}
\begin{itemize}
\item As placas são orientadas horizontalmente; 
\item A placa é caracterizada por uma frequência de alterações entre o caractere (\textit{Foreground}) e a placa (\textit{Background}).
\end{itemize}

     
 Essa etapa consiste em definir uma região  (normalmente um retângulo com a orientação da imagem, mas também pode ser um retângulo rotacionado de modo a se ajustar otimamente a placa) que contenha a imagem. Quanto melhor for o ajuste entre o retângulo e a placa, melhor será o processo de reconhecimento dessa. O processo de geração desse retângulo, utilizado nesse trabalho, foi dividido em duas etapas. Na primeira aplica-se um corte vertical definindo o intervalo de linhas que inclua a placa. Essa região foi denominada de \textit{Band}. A segunda etapa é semelhante, realiza-se um corte horizontal no \textit{band} definindo a região que contém a placa, denominada de \textit{Plate}. A Figura \ref{fig:etapas2} mostra essas duas etapas.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.5, bb=0 0 598 212]{imagens/etapas2.PNG}
\end{center}
\caption{(a) Fotografia de um carro (b) \textit{Band} (c) \textit{Plate}.}
\label{fig:etapas2}
\end{figure}

    O método de localização do \textit{Band} inicia-se com um pré-processamento na imagem do carro. Esse pré-processamento consiste em aplicar um filtro de detecção de arestas verticais (filtro de sobel - vertical) em uma imagem em escala de cinza. Esse processo é mostrado na Figura \ref{fig:etapa_3}.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.2, bb=0 0 1496 950]{imagens/etapa3.PNG}
\end{center}
\caption{(a) Fotografia de um carro (b) imagem convertida para escala de cinza (c) imagem filtrada por Sobel-Vertical.}
\label{fig:etapa_3}
\end{figure}   

    Após o pré-processamento aplica-se uma projeção vertical. Essa projeção consiste em somar a intensidade de cor dos pixels da imagem filtrada linha a linha. Matematicamente, pode-se definir a projeção vertical como uma função $pv: {0,...,h-1}\longrightarrow \mathbb{N}$ onde $pv(i)=\sum_{j=0}^{w-1} I(i,j)$ sendo $I:[0, w]\times[0, h]\longrightarrow{0,1,...,255}]$ a função de intensidade de luz da imagem pré-processada cuja largura é $w$ e altura é $h$. A Figura\ref{fig:etapa_4} mostra o exemplo de uma projeção vertical de uma imagem de um carro.


\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.3, bb=0 0 900 326]{imagens/etapa4.PNG}
\end{center}
\caption{(a) Imagem filtrada por Sobel-Vertical (b) Projeção vertical.}
\label{fig:etapa_4}
\end{figure}   

    Analogamente, no processo de detecção do \textit{plate} aplica-se um pré-processamento, que difere-se do pré-processamento do \textit{band} somente no fato que o filtro de detecção de arestas usado é o filtro de sobel - horizontal. No resultado do pré-processamento aplica-se uma projeção horizontal. Essa projeção é análoga a projeção vertical. Somam-se, coluna a coluna, as intensidades de cor de cada pixel. Matematicamente a projeção horizontal é dada pela função $ph: {0,...,w-1}\longrightarrow \mathbb{N}$ onde $ph(j)=\sum_{i=0}^{h-1} I(i,j)$. A Figura \ref{fig:etapa_5} mostra o exemplo de uma projeção horizontal de uma imagem de um \textit{band}.


\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4, bb=0 0 611 419]{imagens/etapa5.PNG}
\end{center}
\caption{(a) Imagem do band pré-processada (b) projeção horizontal}
\label{fig:etapa_5}
\end{figure} 

    Normalmente o máximo global da projeção vertical está na região que contém a placa. Isso se deve ao fato que em uma imagem de carro filtrada por Sobel-Vertical, normalmente, a região da placa é a região que contém mais arestas e, portanto, essa é a região que contém o máximo global da função. Sendo essa uma função discreta, o processo de detecção de máximo global pode ser determinado por inspeção, sem grandes custos computacionais. A esse valor de máximo global, denominaremos de \textit{pico}.

    Para definir o \textit{band} é necessário encontrar a linha inicial e a linha final da imagem do carro que o determinarão. Para tal é necessário definir uma região próximo ao pico. A abordagem utilizada nesse projeto para definir essa região divide-se em duas etapas. Na primeira, aplica-se uma suavização na projeção vertical. Para isso aplica-se um processo de convolução na imagem da função projeção. Essa convolução calcula a média de valores em uma determinada vizinhança. Após isso, na segunda etapa aplica-se uma função \textit{threshold}, que consiste em, dado um valor $x$ que nesse caso é a média dos valores da imagem da projeção, para cada elemento da imagem da projeção verifica se este é menor que $x$: caso seja, seu valor é zerado. Após essa etapa, tem-se uma função cuja imagem está dividida em intervalos não nulos. Normalmente a placa está no intervalo que contém o pico. Logo, basta extrair o índice inicial e o final que definem esse intervalo e considerá-los como as linhas inicial e final, respectivamente, usadas para o corte do \textit{band}. A Figura \ref{fig:etapa_6} mostra o processo de projeção para determinar o \textit{band}.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4, bb=0 0 823 629]{imagens/etapa6.PNG}
\end{center}
\caption{(a) Imagem original   (b) Projeção vertical suavizada    (c) Aplicação do \textit{Threshold}.}
\label{fig:etapa_6}
\end{figure} 

    O processo de detecção do \textit{plate} é semelhante. Aplica-se a projeção horizontal na imagem do \textit{band} pré-processada, como dito anteriormente. Após essa etapa, aplicam-se as duas etapas de processamento na projeção, assim como feito na projeção vertical, o que resultará em uma função cuja imagem estará dividida em intervalos não nulos. Normalmente a placa está no intervalo de maior comprimento.

    Como dito ao longo do texto, esse processo não é determinístico. Ele baseia-se na alta probabilidade de acerto verificada empiricamente. Porém, pode-se adotar algumas técnicas caso o \textit{band} adotado não seja o que contenha o pico. Isso pode acontecer quando alguma outra região da imagem que contenha o carro contenha algum objeto com riqueza de detalhes, ou haja excesso de ruídos concentrado em uma região. Nessas possibilidades haverá região de alta frequência, além da região da placa. No caso do \textit{band}, pode-se ordenar os intervalos obtidos na etapa final após a projeção. Essa ordenação baseia-se em picos locais (picos nos intervalos). Então os intervalos são organizados decrescentemente baseados nos picos locais. Vale destacar que o conjunto dos picos locais não é o conjunto de máximos locais, pois em um intervalo podem existir mais de um máximo local. Com essa ordenação, continua-se o processo a partir do primeiro intervalo. Caso no fim do processo não encontre nenhuma placa, o processo com o \textit{band} é feito na segunda posição. Analogamente o \textit{plate} pode não estar no intervalo de maior comprimento. Dessa forma realiza-se uma ordenação decrescente baseada no tamanho dos intervalos. Outra alternativa é utilizar algum método para estimar a probabilidade de haver uma placa no \textit{band} e no \textit{plate}. Um método que pode ser utilizado é a Transformada de Hough e verificar se existe um quadrilátero na região determinada pelo \textit{band} ou \textit{plate}. Mais uma vez, esse é um método probabilístico. Porém, vale destacar que a taxa de eficiência do PyANPR é satisfatória.

\section{Pré-processamento da placa}

    Normalmente a imagem da placa contém ruídos ou está em uma baixa resolução. Esses fatores costumam baixar a taxa de acerto do reconhecimento dos caracteres (OCR). Para melhorar a qualidade da imagem, aumentando a taxa de acerto do reconhecimento de caracteres no PyANPR, adotou-se um processo dividido em três etapas. Na primeira etapa, converte-se a imagem para escala de cinza. Na segunda extrai-se o ruído através de um filtro de convolução cujo núcleo baseia-se na mediana. Por fim aplica-se um \textit{threshold} (seção \ref{image:processing}). Um possível valor do limiar é $128$, mas este pode ser alterado caso insira-se alguma outra etapa intermediária. Uma etapa que pode ser utilizada é aplicar um filtro que realce arestas.

    Dessa forma, após o pré-processamento, obtém-se uma imagem binária da placa que servirá de entrada para a próxima etapa, a de reconhecimento de caractere.

 \section{OCR}
\label{sec:ocr}

   O \textit{toolkit} Horus disponibiliza diversos algoritmos para implementação de cada uma das etapas que constituem um sistema OCR (seção \ref{sec:conceito_ocr}). Os algoritmos necessários para a construção das etapas de pré-processamento e segmentação dos caracteres estão disponíveis no módulo de processamento de imagens do Horus, alguns desses algoritmos são: detecção de arestas, binarização, suavização, remoção de ruídos, projeções, entre diversos outros algoritmos.

Após a segmentação dos caracteres, extrai-se um vetor numérico (vetor de características) de cada um desses. Tal vetor é utilizado como padrão de entrada para uma rede neural no processo de reconhecimento. 
O processo de extração de características é uma das etapas mais importantes de um sistema OCR, a qualidade dessa etapa influencia no resultado de todo o sistema. Portanto, a escolha de quais características serão utilizadas como padrão de entrada no processo de reconhecimento é extremamente importante. A construção do vetor de características pode ser feito utilizando os diversos algoritmos implementados no módulo de extração de características do Horus (seção \ref{sec:features}) podem ser: histograma de arestas por regiões, terminação de linha, \textit{loops}, entre outros. Por último, é realizada a etapa de reconhecimento do vetor de características, que finalmente deverá apontar o caractere correto. Uma abordagem usual para a construção da etapa de reconhecimento consiste na utilização de redes neurais artificiais (seção \ref{sec:rna}). O Horus disponibiliza algoritmos para criação e utilização de redes neurais através de uma API \textit{Open Souce} chamada \textit{Fast Artificial Neural Network}(FANN). 

 Atualmente, o \textit{toolkit} Horus não possui um sistema OCR próprio, essa funcionalidade será implementada em um trabalho futuro. Porém, esse \textit{toolkit} disponibiliza funcionalidades de um sistema OCR através da utilização de um OCR \textit{Open Source} chamado Tesseract.  
   
   
\section{Aplicação Web}
    Durante o desenvolvimento deste trabalho, mais especificamente do sistema PyANPR, foi desenvolvido um sistema web cujo objetivo é: através do \textit{upload} de uma imagem de um carro, o sistema realizará o ANPR nessa imagem e retornará todas as informações da placa contidas em seu banco de dados. 
    Esse sistema foi construído utilizando um \textit{framework} \textit{web} de altíssimo nível chamado Django. Esse \textit{framework} é escrito na linguagem de programação Python e é baseado no padrão arquitetural \textit{Model View and Controller}(MVC) \cite{Fowler2003}. 
