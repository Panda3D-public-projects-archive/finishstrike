\chapter{Conceitos Básicos}
\label{cap:conceitos}

Neste capítulo serão apresentados os principais conceitos das áreas de computação gráfica e inteligência computacional que foram utilizados na implementação do \textit{toolkit} Horus. Esses conceitos são de fundamental importância para o entendimento dos algoritmos de visão computacional, processamento de imagens e reconhecimento de padrões implementados nos principais módulos do Horus.

\section{Agentes Inteligentes}
A Inteligência Computacional (IC) é uma área de estudo da ciência da computação que procura desenvolver sistemas computacionais capazes de ter ações e reações similares as capacidades humanas, tais como: pensar, criar, solucionar problemas, entre outros. Um Agente, por definição, é todo elemento ou entidade autônoma que pode perceber seu ambiente por algum meio cognitivo ou sensorial e de agir sobre esse ambiente por intermédio de atuadores \cite{Russel2003}. Pode-se citar como exemplos de agentes inteligentes, além de um robô autônomo ou semi-autônomo, personagens de um jogo, agentes de busca e recuperação de informação e agentes de chats.

Existem diferentes definições para a arquitetura de um robô presentes na literatura. Este trabalho considera a definição abordada por Arkin \cite{Arkin1998} a qual considera que uma arquitetura de um robô está mais relacionada com os aspectos de software que os de hardware. Apesar de algumas diferenças, os modelos de arquitetura para robôs móveis descrevem um mecanismo para construção de um sistema de desenvolvimento e controle de agentes inteligentes, apresentando, principalmente, quais os módulos presentes e como estes interagem. 

De uma forma geral, os módulos de uma arquitetura de um agente inteligente se preocupam com aspectos como percepção, planejamento e atuação$/$execução. A percepção refere-se à compreensão do ambiente e dos elementos nele contido. Denomina-se \textit{sequência de percepções}, a história completa de tudo que o agente já percebeu, ou seja, o conjunto de todas as percepções do agente até um dado momento; o planejamento à inteligência do robô; e a atuação, ou execução, é o modo como o robô procede no ambiente, ou seja, movimentos, captura de informações, etc.

Existem diversos modelos de arquitetura para robótica entre os quais ressaltam-se os modelos de três camadas como: SSS \cite{CONNEL1992}, Atlantis \cite{GAT1991}, 3T \cite{BONASSO1991}. Todas as arquiteturas se dividem semelhantemente da seguinte forma:

    
\begin{itemize}
	\item camada reativa: orienta os sensores e atuadores, além de tomar decisões de baixo nível, como visão e movimento;
	\item camada deliberativa: responsável pela inteligência do robô, aspectos mais globais, que não são alterados a cada iteração;
	\item camada de execução: intermedia essas duas outras camadas.
\end{itemize}
 
As camadas reativa e deliberativa provêem processos denominados de comportamentos. Em termos matemáticos, o comportamento do agente é a função que mapeia qualquer percepção ou sequência de percepções para uma ação específica \cite{Russel2003}, essa função é conhecida como \textit{função de agente}. 

Com base nesses conceitos, definiu-se neste trabalho um agente como uma entidade composta de comportamentos, dispositivos e um programa de agente. Os dispositivos do agente, utilizados no sistema em questão, são de sensoriamento (lasers e câmeras) e de movimentação (rodas). Os comportamentos do agente são: mapeamento, navegação e reconhecimento de objetos. O programa de agente é responsável pelo controle da execução de todos os comportamentos supracitados.

 Os comportamentos são procedimentos implementados para representar ações e reações dos agentes. As ações são comportamentos ativos, ou seja, procedimentos que visam realizar um objetivo previamente definido. Por outro lado, reações são procedimentos realizados mediante a estímulos externos. Exemplos de ação e reação ocorrem no deslocamento de um agente de uma posição a outra. Para realizar o deslocamento é necessário traçar uma rota. Tal comportamento é definido como uma ação. Ao se deparar com algum obstáculo durante o percurso, esse agente deve gerar um comportamento de replanejamento da rota para alcançar o objetivo inical sem colidir com o obstáculo. A esse replanejamento, denomina-se reação.

	Comportamentos podem ser divididos em duas categorias. Os Comportamentos Primários: parar, reduzir velocidade, acelerar, desviar de obstáculos, virar, inverter direção, dirigir-se a meta, fotografar, disparar lasers e etc; e Comportamentos Inteligentes: mapear, reconhecer objetos, navegar e executar uma tarefa específica. Um Comportamento Inteligente executa um conjunto de comportamentos Primários para atingir seu objetivo. Os comportamentos primários ocorrem na camada reativa, enquanto que, os inteligentes ocorrem na camada deliberativa.

Entende-se por \textit{Programa de Agente} o programa que recebe as percepções do ambiente como entrada e as mapeia para uma determinada ação através da função de agente. Além da estrutura citada, o programa de agente pode ser estruturado de outras maneiras. Um exemplo de estrutura é construir o programa de agente como um conjunto de sub-rotinas que serão executadas de forma assíncrona em relação ao ambiente. O programa permanece em \textit{loop}, recebendo todas as percepções geradas pelo ambiente, e repassa cada percepção para uma sub-rotina que irá tratá-las.

Os programas de agente podem ser classificados em quatro categorias principais:
\begin{itemize}
	\item Agentes reativos simples: esse tipo de programa de agente se basea apenas na percepção atual para executar as suas ações, onde a sequência de percepções até o momento é ignorada.
	
	\item Agentes reativos baseados em modelo: esse programa de agente armazena uma sequência de percepções e toma suas decisões levando em consideração as percepções dessa sequência.
	
	\item Agentes baseados em objetivos: esse programa de agente possui informações sobre o objetivo que deve alcançar. Logo, suas decisões são tomadas com base na combinação das percepções do ambiente e nas informações do objetivo.

	\item Agentes baseados na utilidade: esse tipo de programa de agente tem a preocupação, não só de alcançar o seu objetivo final, como também em determinar a melhor forma possível de alcançá-lo. 
\end{itemize}

Em duas das aplicações desenvolvidas neste trabalho, os programas de agente utilizados se enquadram na categoria de agentes baseados na utilidade.

\section{Computação Gráfica}

	A computação gráfica é a ciência que basicamente estuda um conjunto de técnicas que transforma dados em imagem apresentada através de um dispositivo gráfico. Estes dados podem ser organizados através de um modelo matemático cuja geometria se assemelhe a do objeto do mundo real a qual se deseja modelar. Segundo J. Gomes e L.Velho em \cite{Gomes2003} a computação gráfica pode ser dividida em quatro sub-áreas que relacionam dados e imagens. Essas sub-áreas são tão próximas que estão muitas vezes interligadas, em determinados momentos são até confundidas. Estas sub-áreas são: Modelagem Geométrica, Síntese de Imagem, Processamento de Imagem e Visão Computacional. A Figura \ref{fig:CG} mostra estas quatro sub-áreas da computação gráfica e como se relacionam com os dados e a imagem. 

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4, bb= 0 0 564 398]{imagens/CG.PNG}
\end{center}
\caption{Subáreas da computação gráfica.}
\label{fig:CG}
\end{figure}

	A Modelagem Geométrica trata do problema de descrever e estruturar dados geométricos no computador, ou seja, encontrar um modelo matemático capaz de representar o objeto desejado. Um exemplo de Modelagem geométrica é a obtenção de uma função que se aproxime de outra desconhecida através de um método de interpolação de alguns pontos de amostragem já conhecidos.
	
	A Síntese de imagens, ou Visualização, processa os dados gerados pelo sistema na modelagem geométrica e produz uma imagem que pode ser vista em um dispositivo de saída gráfica. A partir do mapeamento de alguns pontos, distribuídos em torno de um determinado objeto, obtém-se um modelo matemático, que o representa, através da Modelagem Geométrica. De posse deste modelo é possível apresentar uma imagem que represente a forma do objeto. Este último processo é um exemplo de Síntese de Imagem.
	
	O Processamento de Imagens assume como dados de entrada uma imagem, processa-a produzindo uma outra imagem como dado de saída. As técnicas desta área podem ser utilizadas, por exemplo, para melhorar a qualidade de uma imagem antiga ou danificada, produzindo outra, imagem com menos ruídos.
	
	Por último, o processo de Visão Computacional, ou simplesmente Visão, tem por finalidade obter, a partir de uma imagem de entrada, informações físicas, geométricas e/ou topológicas sobre os dados do objeto apresentado na imagem. Um bom exemplo desta área aparece nas transmissões de futebol, quando é necessário observar com segurança e certeza se um jogador está em posição de impedimento, ou seja, uma situação onde é necessário determinar a sua posição no campo em relação à posição dos jogadores adversários.
	
	Para determinados pesquisadores a Computação Gráfica é apenas a área denominada de síntese de imagem. Porém para \cite{Gomes2003}, além de outros pesquisadores desta área, esta ciência é composta pelas quatro linhas apresentadas acima. Este fato se justifica graças ao fato de cada vez surgir mais métodos e técnicas que solucionem problemas nestas quatro vertentes.
	
 De um modo geral, visão computacional é a área da computação gráfica que extrai informações de uma imagem ou de um conjunto de imagens. Apesar da definição de visão computacional como uma sub-área da computação gráfica, é válido ressaltar que isso não é aplicado em muitos grupos de pesquisa. A área chamada de visão pode ser renomeada para Análise de Imagem, e essa é, inquestionavelmente, uma sub-área da Computaçao Gráfica.
 
 O problema abordado nesse trabalho é o de Reconhecimento de Padrões. Esse é um problema clássico de Visão Computacional. Mas a maioria das técnicas de visão computacional são combinadas com técnicas de processamento de imagem (normalmente o processamento de imagem entra como um pre-processamento da imagem a ser tratada pelo método de visão). Dessa forma, nesse trabalho serão apresentados esses dois temas da computação gráfica: Processamento de Imagem, na subseção 2 deste capítulo, e Visão Computacional, na subseção 3. 
 
\subsection{Processamento de Imagem}
   Os estudos referentes ao Processamento de Imagem originaram-se na Teoria dos Sinais (ou Processamento de Sinais). Sinais, assim como uma imagem, é um suporte carregado pontualmente de informações.  Os sinais apresentam-se de diversas formas, entre as quais podemos citar: sinais sonoros, sinais eletromagnéticos, sinais cognitivos e sinais luminosos (que nos torna capaz de enxergar um ambiente, ou distinguir elementos de uma imagem). 

    O estudo dos diversos sinais existentes origina-se na obtenção de uma descrição matemática deste. Após isso é necessário determinar meios efetivos de construir representações discretas e buscar de algoritmos que possam implementar as diversas técnicas de síntese, análise e processamento destes sinais em um computador. 

    Segundo o modelo proposto por \cite{Gomes2002} é possível obter três níveis de abstração no processo de representação dos sinais: sinais contínuos, sinais discretos e sinais codificados. Cada nível corresponde a uma descrição do sinal de modo conveniente a um determinado assunto da Teoria dos Sinais. Relacionando esses três níveis de abstração é possível definir quatro operações de transformações: a discretização (mudança de um sinal contínuo para um sinal discreto), a codificação (mudança de um sinal discreto para um sinal codificado), a decodificação (mudança de um sinal codificado para um sinal discreto) e a reconstrução (mudança de um sinal discreto para um sinal contínuo).

    Basicamente um sinal deve ser representado por um elemento matemático que estabeleça a variação de uma determinada grandeza. Por exemplo, o som é a variação da densidade do ar ao longo do tempo; uma imagem é a variação da cor. Desta forma som e imagem podem ser considerados sinais, como mencionado anteriormente. A variação do sinal modelada matematicamente pode ser determinística, onde se utilizam uma função como modelo do sinal, ou não determinística, onde o sinal é descrito através de um processo estocástico.

No caso que o sinal é modelado por uma função $f: U \subset \mathbb{R}^{m} \longrightarrow \mathbb{R}^{n}$ a grandeza física do sinal é representada por vetor $n$-dimensional variando em um suporte $m$-dimensional. Denomina-se espaço dos sinais a um subespaço de funções de $\left\lbrace f: U \subset \mathbb{R}^{m} \longrightarrow \mathbb{R}^{n}\right\rbrace $, com $U$, $m$ e $n$ fixos. Desta forma um espaço de funções é um espaço vetorial cujas operações de soma de funções e multiplicação por escalar são as usuais.

\begin{center}
    $\left( f + g\right)(t) = f(t) + g(t)$

    $(\lambda f)(t) =\lambda f(t)$
\end{center}


	De posse desta informação pode-se definir um sinal contínuo, em um espaço de sinais, como a função $f: U \subset \mathbb{R}^{m} \longrightarrow \mathbb{R}^{n}$. Porém vale ressaltar que o termo contínuo não quer dizer que necessariamente a função $f$ é topologicamente contínua. Na verdade significa que domínio e contra-domínio são um "continuum" de números, ou seja, conjuntos vetoriais cujas coordenadas dos elementos são números reais. Essa ressalva deve-se principalmente pelo fato que computacionalmente falando, não se trabalham com o conjunto dos números reais, mas na verdade utiliza-se um conjunto finito de elementos representado através de ponto flutuante. Para simplificar essa discussão vale citar o termo mais popular para este sinal continuo: analógico.

    Dado um sinal contínuo definido pela função $f: U \subset \mathbb{R}^{m} \longrightarrow \mathbb{R}^{n}$, entre as operações definidas entre os níveis de abstração dos sinais, a operação de discretização (ou representação) consiste em discretizar o domínio da citada função (processo conhecido como amostragem), enquanto a codificação é a discretização do contradomínio (processo conhecido como quantização).

    Não é pretensão deste trabalho esgotar este assunto. Uma abordagem um pouco mais elaborada pode ser encontrada em \cite{Gomes2002}.

    O processamento de imagem, como definido anteriormente, consiste em, a partir de uma imagem, obter uma outra imagem com determinados aspectos realçados. Ou seja, processar uma imagem consiste em realizar sucessivas transformações para obter determinadas informações contidas nesta com mais facilidade. 

    Um desejo desta área é o de processar uma imagem analogamente como é realizado pelo sistema visual humano. Porém este sistema é extremamente complexo. Para realizar as mesmas operações utilizando máquinas é necessário fazer com que esta tenha uma real compreensão do ambiente analisado. Desta forma o processamento de imagem está extremamente inter-relacionado com sua área de aplicação, ao invés de um sistema amplo capaz de identificar qualquer objeto, a partir de uma imagem, em boas condições, dada.

    Ao se estudar o processamento de Imagem deve-se anteriormente ter um domínio claro de o que é uma Imagem. Do ponto de vista da ótica, uma imagem é um conjunto de pontos, com uma identidade fotométrica, que convergem formando um todo. Matematicamente falando, uma Imagem Contínua é uma aplicação $f: U \subset \mathbb{R}^{2} \longrightarrow C$, onde $C$ é o espaço das cores, $f$ é chamada de Função Imagem, $U$ é o suporte da Imagem e $f(U)$, um subconjunto de $C$, é o gamute de cores da imagem. Em geral $C = \mathbb{R}^{n}$, porém os casos mais comuns são: para $n = 3$ (como RGB), ou $n = 1$ (como imagens em escala de cinza).
    
    Inicialmente o termo imagem estava relacionado à compreensão do domínio da luz visível. Atualmente pode-se pensar em imagens como uma grande quantidade de dados representados bidimensionalmente, entre os quais podem-se citar as imagens acústicas, sísmicas, de satélites, infravermelhas, magnéticas, entre outras.

    A linha de pesquisa denominada Processamento de Imagem consiste em realizar operações sobre uma imagem. Essas operações normalmente sao determinadas por funçoes, cujo dominio é a imagem a ser processada e o contra-domínio é o espaço das funções.
    
\subsection{Visão Computacional}

Outra área da Computaçao Gráfica é a Visão computacional. Visão computacional ainda pode ser considerada como uma área imatura de pesquisa. Embora existam trabalhos reconhecidos, somente após o final da década de 1970 os estudos foram aprofundados com o advento do computador possibilitando processar grandes conjuntos de dados como imagens. Esse ínicio teve grande impulso com David Marr, considerado o "pai" da Visão Computacional. David Marr morreu em 17 de novembro de 1980, porém seu livro \cite{David:82} foi lançado postumamente em 1982 e causou um forte impacto na comunidade de visao computacional. Entretanto, esses estudos foram geralmente originados de outros campos de pesquisa, e, consequentemente, não existe uma formulação padrão para o problema de visão computacional, assim como não existe uma formulação padrão de como os problemas de visão computacional devem ser resolvidos. O que existem atualmente, são diversos métodos para resolver várias tarefas bem definidas, no qual os métodos são bastante especializados e raramente podem ser generalizados para várias aplicações. Na maioria das aplicações de visão computacional, os computadores são pré-programados para resolver uma tarefa particular, mas métodos baseados em aprendizagem estão se tornando cada vez mais comuns.

Visão computacional é uma linha de pesquisa que procura definir procedimentos automatizados que imitem processos da visão humana (ou de outros animais).  Normalmente essa área basea-se em técnicas estatísticas, ou probabilísticas, para estimar informações baseadas em imagens. Para desenvolver técnicas nessa linha de pesquisa é essencial uma boa compreensão sobre o funcionamento das câmeras (com suas falhas na aquisisão de sinais que compõem uma imagem, inserção de ruídos, distorção de cores, etc), assim como seu posicionamento no espaço ambiente. Esse segundo problema é conhecido como calibração de câmera e é um tema largamente estudado, pois normalmente, para estimar informações em uma cena vista em duas dimensões é necessário ter noções sobre profundidade, que é estimada através da especificação da posição da câmera e de objetos na cena.

De um modo geral, visão computacional é a área da computação gráfica que extrai informações de uma imagem ou de um conjunto de imagens. Apesar da definição de visão computacional como uma sub-área da computação gráfica, é válido ressaltar que isso não é aplicado em muitos grupos de pesquisa. A área chamada de visão pode ser renomeada para Análise de Imagem, e essa é, inquestionavelmente, uma sub-área da Computaçao Gráfica.


 Existem diversas aplicações de visão computacional em diversas áreas como detecção automática de tumores em imagens médicas; definição de posição de jogadores de futebol no campo, em um determinado instante; determinação de volume de um fluido em mares ou rios, etc.

Nesse trabalho foi estudado um tema particular de visão computacional, que é o de reconhecimento de padrões, seção \ref{sec:recObj}. Para reconhecer padrões, assim como na maioria dos problemas de visão computacional, é necessário extrair características da imagem.



\subsection{Reconhecimento de Padrões}
\label{sec:recObj}
Reconhecimento de padrões é uma atividade que os seres humanos fazem a todo tempo e, normalmente, sem um esforço consciente. Seres humanos recebem informações através de vários sensores orgânicos, as quais são processadas instantaneamente pelo cérebro. Essa habilidade é ainda mais impressionante no que diz respeito a assertividade do processo de reconhecimento mesmo quando as informações não se encontram em condições ideais, como por exemplo, em situações onde as informações são vagas, imprecisas, ou até mesmo, incompletas.
	A área de Reconhecimento de Padrões é responsável por projetar algoritmos e abordagens  que procuram aproximar as tarefas realizadas computacionalmente das habilidades humanas. Esse processo consiste em classificar e descrever objetos através de um conjunto de características ou propriedades. Um dos principais conceitos dentro de reconhecimento de padrões é o discriminante.  Tal conceito consiste em medir uma distância de um determinado padrão para cada outro previamente conhecido. Logo, a classe de um determinado padrão será a mesma do seu vizinho mais próximo \cite{Simpson}, cite{Simp:93}, de menor distância ou o protótipo mais parecido \cite{Torb:98}.
    	Espera-se de um  sistema de reconhecimento de padrões que este seja capaz de aprender de uma forma adaptativa e dinâmica. Em sistemas de reconhecimento de padrões automáticos, as etapas de aprendizagem e reconhecimento são combinados a fim de atingir um objetivo desejado cite{Cagn:93}. Portanto, redes neurais artificiais é uma das principais técnicas utilizadas nesse sentido cite{ Nigr:93} e será apresentada na seção \ref{sec:rna}.
 	Um típico sistema de reconhecimento de padrões consiste em três partes: aquisição de dados, seleção$/$extração de características e classificação$/$clustering cite{Sankar04}.

\begin{itemize}
\item Aquisição de dados: é o processo de seleção dos dados que serão usados como entrada no processo de reconhecimento. Tais dados podem ser qualitativos, quantitativos ou ambos. Podendo ser numéricos, linguísticos, entre outros. 

\item Seleção$/$Extração de características: o objetivo principal desta etapa consiste em gerar o melhor conjunto de características necessárias para o processo de reconhecimento, de modo a maximizar a eficácia do sistema.  A grande dificuldade dessa etapa está na determinação de um critério adequado para a escolha de um bom conjunto de características. Um bom critério é aquele que é imutável para qualquer variação possível dentro de uma classe, todavia, deve ser capaz de destacar as diferenças importantes a fim de discriminar entre diferentes tipos de padrões.

\item Classificação$/$clustering: classificação é o processo de definição de qual classe um determinado padrão de entrada pertence. Essa classificação pode ser feita utilizando técnicas determinísticas e probabilísticas. As classes são definidas a partir de um conjunto de amostras apresentadas na etapa de aprendizagem.

\end{itemize}

A área de reconhecimento de padrões possui grande variedade de aplicações, como reconhecimento de faces, leitura biométrica, identificação de circuitos impressos defeituosos, reconhecimento óptico de caracteres, reconhecimento de fala e de escrita cursiva, entre outros.  

Um padrão em particular que podemos citar são caracteres. O campo de pesquisa, dentro da visão computacional, que se preocupa com o reconhecimento de caracteres é conhecido pelo acrônimo OCR, do inglês, Optical Recognition Caracter. Esse tema será abordado na seção \ref{sec:ocr}.


\subsection{Reconhecimento Óptico de Caracteres}
\label{sec:conceito_ocr}
Reconhecimento Óptico de Caracteres ou OCR (\textit{Optical character recognition}) é um campo de pesquisa nas áreas de reconhecimento de padrões, inteligência artificial e visão computacional. Em computação, OCR é o processo de tradução eletrônica de imagens de textos para textos que possam ser editados computacionalmente, permitindo assim, a realização de operações que seriam inviáveis de serem realizadas sobre o texto em formato de imagem. Sistemas OCR, ou de reconhecimento de caracteres, datam do final dos anos 50 e têm sido amplamente utilizados em computadores desktop desde os anos 90.

	Esses sistemas disponibilizam textos contidos em imagens, capturadas por dispositivos ou geradas computacionalmente, em textos editáveis por computador. Os textos gerados por sistemas OCR são, normalmente, utilizados por outras ferramentas que permitem operações, como a busca de determinado conteúdo de interesse.
	
	Apesar de mais de 40 anos de pesquisa, sistemas OCR ainda estão muito longe de alcançar a eficácia de um ser humano. A eficácia desses sistemas está fortemente ligada à qualidade das imagens. Imagens limpas e de alta qualidade levam esses sistemas a atingirem uma taxa de aproximadamente 99\textdiscount de eficácia \cite{Rice1999}. Porém, imagens com baixa resolução, com ruído ou com diferenças de luminosidade, por exemplo, podem levar esses sistemas a cometerem erros grosseiros e confundirem diversos tipos de caracteres. Caracteres como "6" e "9", "B" e "8" e "o" e "0", são facilmente confundidos em imagens imperfeitas.
	
	Nesse sentido, atualmente, boa parte das pesquisas em OCR está focada na melhoria da sua eficácia no que diz respeito à extração de textos de imagens que não se encontram em condições ideais. Além disso, o reconhecimento de textos escritos a mão em linguagem cursiva ainda são uma área de pesquisa muito ativa. O processo de OCR é constituído de várias etapas, com responsabilidades bem definidas, que ao final apresentam o texto editável. A Figura \ref{fig:etapasOCR} apresenta um esquema básico do processo de OCR.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4, bb= 0 0 372 718]{imagens/etapasOCR.PNG}
\end{center}
\caption{Etapas do processo de OCR.}
\label{fig:etapasOCR}
\end{figure}

	Na Figura \ref{fig:etapasOCR}, têm-se as várias etapas de um processo clássico de OCR. Inicialmente, é necessário tornar a imagem binária, isto é, transformar a imagem, que se encontra em escala de cinza, em uma imagem com apenas duas cores: preto e branco, cores essas representadas respectivamente pelos inteiros 0 e 255. Na etapa de segmentação, cada caractere presente na imagem é recortado da imagem binária para ser tratado individualmente. Após a segmentação, cada caractere é passado individualmente para a etapa de extração de características, onde um vetor numérico é extraído a partir das características desse caractere. Por último, é realizada a etapa de reconhecimento do vetor de características, que finalmente deverá apontar o caractere correto.
	Cada etapa desse processo pode ser implementada de diversas maneiras e por vários algoritmos diferentes. No capítulo \ref{cap:horus} serão apresentados alguns algoritmos que podem ser utilizados no processo de OCR.
	
\subsection{Extração de características}

	No campo de reconhecimento de padrões, extrair caracerísticas significa extrair medidas associadas ao objeto que se deseja reconhecer, de forma que essas medidas sejam semelhantes para objetos semelhantes e diferentes para objetos distintos \cite{Santos2007}. Definir vetores de características é o método para representação de dados mais comum e conveniente para problemas de classificação e reconhecimento. Cada característica resulta de uma medição qualitativa ou quantitativa, que é uma variável ou um atributo do objeto \cite{Guyon2006}.

	Para reconhecer um caractere de uma representação bitmap, há a necessidade de extrair características do mesmo para descrevê-lo de uma forma mais apropriada para o seu processamento computacional e reconhecimento. Como o método de extração de características afeta significantemente a qualidade de todo o processo de reconhecimento de padrões, é muito importante extrair características de modo que elas sejam invariantes no que diz respeito às várias condições de iluminação, tipo de fonte e possíveis deformações nos caracteres causadas, por exemplo, pela inclinação da imagem.
        
	Geralmente, a descrição de uma região de uma imagem é baseada em suas representações interna e externa. A representação interna de uma imagem é baseada em suas propriedades regionais, como cor ou textura. A representação externa é selecionada quando se deseja dar ênfase nas características da forma do objeto. Logo, o vetor de características de uma representação externa inclui características como o número de linhas, a quantidade de arestas horizontais, verticais e diagonais, etc.
        
	O conjunto de vetores de características forma um espaço vetorial. Cada caractere representa uma determinada classe, e todas as formas de representação desse caractere definem as instâncias dessa classe. Todas as instâncias do mesmo caractere devem ter uma descrição similar através de vetores numéricos chamados de "descritores", ou "padrões". Logo, vetores suficientemente próximos representam o mesmo caractere. Essa é a premissa básica para que o processo de reconhecimento de padrões seja bem sucedido.

No capítulo que trata do \textit{toolkit} Horus, serão explicados alguns métodos de extração de características implementados no módulo de visão computacional.



\section{Inteligência Computacional}

A Inteligência Computacional (IC) é uma linha de pesquisa dentro de Ciência da Computação que tem o objetivo de desenvolver sistemas que imitem algumas capacidades especificas dos seres humanos \cite{Russel2003}. Esses sistemas são denominados \textit{Sistemas Inteligentes}. Como exemplo de capacidades humanas que inspiram o desenvolvimento desse tipo de sistema têm-se: aprendizado, percepção, raciocínio, evolução e adaptação. Nesse sentido, cada técnica de Inteligência Computacional foi fortemente influenciada por aspectos naturais dos seres humanos. Como exemplo de técnicas de IC pode-se citar:

\begin{itemize}

	\item Sistemas Especialistas: são programas desenvolvidos para solucionar problemas de uma área específica do conhecimento humano. Esses sistemas armazenam o conhecimento de um especialista, de uma determinada área, em forma de código e são capazes de tomar decisões com base nesse conhecimento.
	
	\item Redes Neurais Artificiais: são modelos computacionais não lineares inspirados na forma de operação da rede neural do cérebro humano. Essa técnica visa reproduzir as capacidades de aprendizado, associação, generalização e abstração dos seres humanos, sendo bastante eficiente no aprendizado de padrões.
	
	\item Algoritmos Genéticos: são algoritmos que fornecem um mecanismo de busca adaptativa que se baseia no mecanismo de adaptação e evolução natural e recombinação genética de \textit{Darwin}. Essa técnica possui uma população de indivíduos (soluções), representados por cromossomos. Cada indivíduo é então submetido a um processo de avaliação, onde é medida a sua aptidão para o problema. Os melhores indivíduos são selecionados e seus cromossomos são combinados. Esse processo é realizado de forma iterativa até obter um resultado satisfatório.

	\item  Lógica \textit{Fuzzy}: lógica \textit{Fuzzy} tem o objetivo de modelar a capacidade de aproximação do raciocínio humano. Essa técnica tem o objetivo de desenvolver sistemas capazes de fornecer soluções aceitáveis em ambientes onde as informações de entrada são incertas ou imprecisas.
\end{itemize}

Dentre as várias técnicas de inteligência computacional, a técnica que foi utilizada nesse trabalho foi a de Redes Neurais Artificiais devido ao seu grande poder de aprendizado de padrões e generalização. Essas características são muito importantes na resolução do problema de reconhecimento de padrões abordado por este trabalho. A técnica de redes neurais artificiais será apresentada na próxima sessão.

\section{Redes Neurais Artificiais}
\label{sec:rna}
Redes Neurais Artificiais (RNAs) são estruturas computacionais que visam imitar a forma com que o cérebro humano processa as informações. O cérebro possui a capacidade de organizar e encadear seus elementos estruturais, conhecidos como neurônios, para realizar o processamento das informações de forma não linear e paralela. Dessa forma, as principais características das redes neurais são a habilidade de aprender relações complexas e não lineares entre os padrões de entrada e as saídas, utilizarem procedimentos de treinamento seqüencial e se auto-adaptar aos dados \cite{Jain2000}.

	Na sua forma geral, uma rede neural é uma máquina projetada para imitar a forma com que o cérebro realiza uma tarefa particular ou uma função de interesse, podendo ser implementada em hardware ou simulada através de software. Para atingir uma performance razoável, as redes neurais empregam uma massiva interconexão de unidades de processamento simples, denominadas neurônios \cite{Haykin1994}. 

As redes neurais artificais possuem a capacidade de aprendizado e, como conseqüência, de generalização. Generalização refere-se à produção de saídas racionais para entradas que não foram apresentadas a rede durante a fase de treinamento ou aprendizado. As capacidades de aprendizado e de generalização tornam as redes neurais capazes de resolver problemas complexos e não-lineares. A seguir, serão explicadas algumas características do neurônio biológico, fundamentais para o entendimento das RNAs.

\subsection{Neurônio Biológico}

O sistema nervoso é formado por um conjunto extremamente complexo de neurônios. Os neurônios estão conectados uns aos outros através de sinapses. Nos neurônios a comunicação é realizada através de impulsos elétricos, quando um impulso é recebido, o neurônio o processa, e passado um limite de ação, dispara um segundo impulso o qual flui do corpo celular para o axônio que, por sua vez, pode ou não estar conectado a um dendrito de outra célula. A Figura \ref{fig:neuroBiol} apresenta uma representação de um neurônio.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.35, bb= 0 0 751 469]{imagens/neuronioBio.PNG}
\end{center}
\caption{Neurônio biológico.}
\label{fig:neuroBiol}
\end{figure}

Os principais componentes de um neurônio são:
\begin{itemize}
\item Os dendritos: membrana que recebe os estímulos gerados por outras células. Os dendritos são as entradas do neurônio.

\item Soma: é o corpo do neurônio, que é responsável por coletar e combinar informações vindas de outros neurônios;

\item O axônio: membrana constituída de uma fibra tubular que é responsável por transmitir os estímulos para outras células. O axônio representa a saída do neurônio.
\end{itemize}

O neurônio biológico é constituído de um corpo celular denominado soma. Nesse Local ocorre o processamento metabólico da célula nervosa ou neurônio. A partir da soma, projetam-se extensões filamentares denominadas dendritos, e o axônio. Este modelo anatômico foi identificado por Ramon Cajal em 1894. Com base nas pesquisas de Erlanger e Gasser, em 1920, e outras posteriores, passou-se a entender o comportamento do neurônio biológico como sendo o dispositivo computacional do sistema nervoso, o qual possui muitas entradas e uma única saída \cite{Haykin1994}.

	As entradas ocorrem através das conexões sinápticas, que conectam a árvore dendrital aos axônios de outras células nervosas. Os sinais que chegam pelos dendritos são pulsos elétricos conhecidos como impulsos nervosos ou potenciais de ação, e constituem a informação que o neurônio processará de alguma forma para produzir como saída um impulso nervoso no seu axônio.

	Sinapse é o nome dado ao ponto de contato entre a terminação axônica de um neurônio e o dendrito de outro.  É pelas sinapses que os nodos se unem funcionalmente, formando a rede neural.  As sinapses funcionam como válvulas, e são capazes de controlar a transmissão de impulsos entre os nodos na rede \cite{Braga2000} e estão compreendidas entre duas membranas celulares: a membrana pré-sináptica, que recebe o estímulo vindo de uma célula, e a membrana pós-sináptica, que é a do dendrito. Na região pré-sináptica, se o estímulo nervoso recebido atinge um determinado limiar em um espaço curto de tempo, a célula "dispara", produzindo um impulso que é transferido para outras células através de neurotransmissores presentes na membrana dendrital. Dependendo do neurotransmissor, a conexão sináptica é excitatória ou inibitória. A conexão excitatória provoca uma alteração no potencial da membrana que contribui para formação do impulso nervoso no axônio de saída, enquanto que a conexão inibitória age no sentido contrário.

	O mecanismo como é criado o potencial de ação ou impulso nervoso é o seguinte: quando o potencial da membrana está menos eletronegativo do que o potencial de repouso, diz-se que a membrana está despolarizada e quando está mais negativo, diz-se que ela está hiperpolarizada. O impulso nervoso ou potencial de ação é uma onda de despolarização de certa duração de tempo, que se propaga ao longo da membrana. A formação de um potencial de ação na membrana axonal ocorre quando essa membrana sofre despolarização suficientemente acentuada para cruzar um determinado valor conhecido como limiar de disparo. Quando esse limiar é superado, os estímulos são passados para outras células através das ligações sinápticas.

\subsection{O Neurônio Artificial MCP}
McCulloch e Pits \cite{Mendel1970} propuseram um modelo matemático do neurônio artificial MCP. Esse modelo foi proposto com base nos principais conceitos do neurônio biológico. O modelo matemático do neurônio proposto por McCulloch e Pits apresenta $n$ terminais de entrada $x_1, x_2, ..., x_n$ (representando os dendritos) e apenas um terminal de saída $y$ (representando o axônio). Os terminais de entrada do neurônio têm pesos acoplados $w_1,w_2, ..., w_n$ cujos valores podem ser positivos ou negativos caso as sinapses correspondentes serem inibitórias ou excitatórias. O efeito de uma sinapse particular $i$ no neurônio pós-sináptico é dado por $x_i w_i$. Os pesos determinam o nível em que o neurônio deve considerar sinais de disparo que ocorrem naquela conexão. O modelo está ilustrado na Figura \ref{fig:mcculloch}.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.55, bb= 0 0 349 264]{imagens/mcculloch.PNG}
\end{center}
\caption{Modelo do neurônio de McCulloch e Pits.}
\label{fig:mcculloch}
\end{figure}

O corpo do neurônio realiza um simples somatório dos valores $x_iw_i$ que chegam a ele. Se o somatório dos valores ultrapassa o limiar de ativação ou \textit{threshold}, o neurônio dispara (valor 1 na saída), caso contrário o neurônio permanece inativo (valor 0 na saída). A ativação do neurônio é realizada através de uma função de ativação, que dispara ou não o neurônio dependendo do valor da soma ponderada das suas entradas. No modelo MCP original, a função de ativação ativará a saída quando:

\begin{center}


$\sum_{i=1}^{n} x_{i}w_{i} \geq \theta$


\end{center}

Na equação acima, $n$ é a quantidade de entradas do neurônio, $w_i$ é o peso associado à entrada $x_i$ e $\theta$ é o limiar do neurônio.

\subsection{Funções de Ativação}
A partir do modelo apresentado por McCulloch e Pits, surgiram vários outros modelos que permitem a produção de qualquer saída, não apenas zero ou um, e com várias funções de ativação. As funções de ativação mais comuns são: 


\begin{itemize}
\item Função Limiar: função utilizada no modelo de McCulloch e Pits, caracterizada por "tudo ou nada", representada da seguinte forma:   \[ f(v) = \left\{
                                 \begin{array}{ll}
                                     1,  $ v $ \geq 0\\
                                     0,  $ v $ \leq 0
                                 \end{array}
                           \right. \]



Onde $v$ é igual ao valor produzido pelo somatório das entradas do neurônio. 

\begin{figure}[!htb]
\centering
\begin{center}
  \includegraphics[scale=0.5, bb= 0 0 300 222]{imagens/graficoFuncaoLimiar.PNG}
\end{center}
\caption{Gráfico da função Limiar.}
\label{fig:fLimiar}
\end{figure}


\item Função Sigmóide: essa é uma função semilinear, limitada e monotônica que pode assumir valores entre $0$ e $1$. Existem várias funções sigmodais, porém, a mais usada é a função logística definida pela equação: 

\begin{center}
    $f(v) = \frac{1}{1+e^{(-av)}}$
\end{center}

Onde $a$ é o parâmetro de inclinação da função sigmóide e $v$ é o valor de ativação do neurônio.

\begin{figure}[!htb]
\centering
\begin{center}
 \includegraphics[scale=0.5, bb= 0 0 290 220]{imagens/graficoFuncaoSigmoide.PNG}
\end{center}
\caption{Gráfico da função sigmóide.}
\label{fig:funcSignum}
\end{figure}

\item Função Signum: essa função apresenta as mesmas características da função limiar, porém, se limita ao intervalo entre $1$ e $-1$. Essa função é representada por:  

\begin{center}
    $f(v) = b\frac{v}{|v|} $ para $ v \neq 0$
\end{center}

Onde $b$ são os limites inferiores e superiores $(b = |1|$ no gráfico$)$ e $v$ é o valor de ativação.

\begin{figure}[!htb]
\centering
\begin{center}
 \includegraphics[scale=0.5, bb= 0 0 280 208]{imagens/graficoFuncaoSignun.PNG}
\end{center}
\caption{Gráfico da função Signum.}
\label{fig:graficoSignum}
\end{figure}

\item Tangente Hiperbólica: seu gráfico é parecido com o da Função Sigmóide, assumindo valores entre $1$ e $-1$, sendo representada por:

\begin{center}
    $f(v) = a\frac{e^{(bv)} - e^{(-bv)}}{e^{(bv)} + e^{(bv)}} $
\end{center}

Onde a é o parâmetro de inclinação da curva, b são os limites inferiores e superiores $(b = |1|$ no gráfico$)$ e $v$ o valor de ativação.

\begin{figure}[!htb]
\centering
\begin{center}
\includegraphics[scale=0.35, bb= 0 0 279 207]{imagens/graficoHiperbolica.PNG}
\end{center}
\caption{Gráfico da Tangente Hiperbólica.}
\label{fig:graficoHiperbolica}
\end{figure}

\end{itemize}



\subsection{Arquiteturas de Redes Neurais}
A definição da arquitetura de uma RNA define a maneira com que os neurônios são estruturados na rede \cite{Haykin1994}. A arquitetura restringe o tipo de problema que pode ser tratado pela rede. Redes com uma camada única de nodos MCP, por exemplo, só conseguem resolver problemas linearmente separáveis. Redes recorrentes, por sua vez, são mais apropriadas para resolver problemas que envolvem processamento temporal \cite{Braga2000}. A arquitetura de uma rede é definida pelos seguintes parâmetros: número de camadas da rede, número de neurônios em cada camada, tipo de conexão entre os neurônios e topologia da rede.
	
Em geral, as redes neurais podem ser classificadas quanto ao número de camadas, quanto ao tipo de conexão e quanto à conectividade entre os neurônios. Quanto ao número de camadas têm-se:

\begin{itemize}
\item Redes de uma única camada: existe apenas um nó entre uma entrada e uma saída da rede. A Figura \ref{fig:unicacamada} apresenta um exemplo de redes de única camada.

\begin{figure}[htb]
\centering
\begin{center}
    \includegraphics[scale=0.6, bb= 0 0 125 123]{imagens/redeUmaCamada.PNG}
\end{center}
\caption{Rede de uma única camada.}
\label{fig:unicacamada}
\end{figure}

\item Redes de múltiplas camadas: existe mais de um neurônio entre alguma entrada e alguma saída (Figura \ref{fig:multiplaCamada}).

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.6, bb= 0 0 171 103]{imagens/redeMultiplaCamada.PNG}
\end{center}
\caption{Rede de múltiplas camadas.}
\label{fig:multiplaCamada}
\end{figure}
\end{itemize}

Quanto ao tipo de conexão têm-se:

\begin{itemize}
\item Feedforward, ou acíclica: a saída de um neurônio na $i$-ésima camada da rede não pode ser usada como entrada de nodos em camadas de índice menos ou igual a $i$ Figura \ref{fig:unicacamada}.

\item Feedback, ou cíclica: a saída de algum neurônio na $i$-ésima camada da rede é utilizada como entrada em neurônios da camada de índice menor ou igual a $i$ (Figura \ref{fig:feedback}).

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.6, bb= 0 0 182 115]{imagens/feedBack.PNG}
\end{center}
\caption{Exemplo de rede feedback.}
\label{fig:feedback}
\end{figure}

Quanto à conectividade têm-se:

\begin{itemize}
\item Redes parcialmente conectadas (Figura \ref{fig:unicacamada}).
\item Redes completamente conectadas (Figura \ref{fig:multiplaCamada}).

\end{itemize}

\subsection{Processo de aprendizado}
	A principal propriedade de uma rede neural é a sua habilidade de aprender sobre o ambiente no qual está inserida de forma a melhorar a sua performance na resolução de problemas complexos. Essa melhora na performance é adquirida a cada instante do processo de aprendizado de acordo com uma forma de medição pré-estabelecida. Com isso, uma rede neural aprende sobre seu ambiente através de um processo iterativo de ajuste dos pesos sinápticos adquirindo mais conhecimento sobre o problema após cada iteração do processo de aprendizado.
	Segundo Mendel e McLaren \cite{Mendel1970}, no contexto de redes neurais, aprendizado é o processo pelo qual os parâmetros de uma rede neural são ajustados através de estímulos produzidos pelo ambiente no qual a rede está inserida. O tipo de aprendizado é determinado pela maneira particular com que os parâmetros são modificados.
	O Horus disponibiliza diversos métodos de treinamento de redes, podendo ser agrupados em dois paradigmas principais: aprendizado supervisionado e aprendizado não-supervisionado. No entanto, outros dois paradigmas bastante conhecidos são os de aprendizado por reforço (que é um caso particular de aprendizado supervisionado) e aprendizado por competição (que é um caso particular de aprendizado não supervisionado). 

\begin{itemize}
\item Aprendizado Supervisionado:


Esse tipo de aprendizado é o mais utilizado em RNAs. Esse aprendizado é dito supervisionado porque as entradas e as respectivas saídas desejadas são fornecidas por um supervisor externo, normalmente chamado de "professor". Seu objetivo é ajustar os pesos da rede, de forma a encontrar uma ligação entre os pares de entrada e saída fornecidos pelo professor.
	O professor é responsável por direcionar o processo de aprendizado fornecendo os padrões de entrada, as saídas desejadas e a taxa de erro desejada.  A cada padrão de entrada submetido à rede pelo professor, compara-se a resposta desejada (que representa uma solução ótima para aquele padrão de entrada) com a resposta calculada, ajustando-se os pesos das conexões para minimizar o erro. A minimização da diferença é incremental, já que pequenos ajustes são feitos nos pesos a cada iteração do aprendizado. A soma dos erros quadráticos de todas as saídas é normalmente utilizada como medida de desempenho da rede e também como função de custo a ser minimizada pelo algoritmo de treinamento. A Figura \ref{fig:aprendSuper} apresenta um esquema básico de aprendizado supervisionado.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.55, bb= 0 0 348 211]{imagens/aprendizadoSupervRNA.PNG}
\end{center}
\caption{Esquema de aprendizado supervisionado.}
\label{fig:aprendSuper}
\end{figure}

Nesse trabalho, o algoritmo de aprendizado utilizado foi o \textit{backpropagation}.


\item Aprendizado Não Supervisionado:


No aprendizado não supervisionado não há um professor que oriente o processo de aprendizado. Ao contrário do aprendizado supervisionado, que possui pares de entrada e saída, para esses algoritmos somente são disponibilizados os padrões de entrada. De acordo com as regularidades estatísticas com que as entradas ocorrem, a rede cria classes de acordo com as características extraídas de cada padrão de entrada. Dessa forma, para cada entrada fornecida a rede, a saída será a classe a qual a entrada pertence.  Caso a entrada não pertença a nenhuma classe pré-existente, a rede cria uma nova classe para essa entrada. A base para a utilização desse tipo de aprendizado é a redundância nos dados, sem redundância, seria praticamente impossível a utilização bem sucedida do aprendizado não supervisionado. A Figura \ref{fig:aprendNaoSuper} apresenta um esquema de um sistema de aprendizado não supervisionado.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.55, bb= 0 0 445 93]{imagens/aprendizadoNSuper.PNG}
\end{center}
\caption{Esquema de aprendizado não supervisionado.}
\label{fig:aprendNaoSuper}
\end{figure}


\end{itemize}




