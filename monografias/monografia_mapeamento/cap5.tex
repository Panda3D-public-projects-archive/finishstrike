%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  O Tool Kit Horus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{O Toolkit Horus}
\label{cap:o_toolkit_horus}

O Horus é um \textit{Toolkit}, ou seja, uma coleção de ferramentas (nesse caso módulos) que servem para gerenciar agentes inteligentes, escrito em \textit{Python}. Duas partes estão sendo desenvovdidas a princípio: Módulo de Visão e Módulo de Mapeamento.

No módulo de visão estão os mais variados algoritmos de visão computacional e no módulo de mapeamento trata-se do problema de mapear ambientes a partir de dispositivos de leitura do ambiente e de efetuadores.
\section{Objetivo}

O objetivo do Toollkit é prover ferramentas necessárias para produção de agentes inteligentes, focando nos processos de navegação e mapeamento no que diz respeito à movimentação dos agentes em um ambiente e também na identificação de placas e reconhecimento dos caracteres no que diz respeito à parte de visão computacional disponibilizada neste toolkit denominado Horus

\section{Módulos do Horus}

As principais funcionalidades de cada um dos módulos são:
\begin{itemize}
\item Core do Horus: Contêm módulos que serão utilizados como suporte para os módulos principais. Sendo assim não necessitam ser utilizados diretamente pelo usuário.
\item Módulo de Visão: Tem por objetivo tratar as principais técnicas de visão computacional de um agente inteligente.
\item Modulo de Mapeamento: O módulo de mapeamento é responsável por gerenciar os tipos de mapeamento bem como os dispositivos utilizados para mapear e navegar no ambiente.
\item Utils: Módulo que contêm funções de suporte para auxiliar no funcionamento dos demais módulos.
\end{itemize}

\subsection{\textit{Core} do Horus}

O Core do Horus é onde se encontram as partes relativas ao agente e seus comportamentos.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4675,bb=0 0 902 386]{imagens/digramas/diagrama_core.png}
\end{center}
\caption{Diagrama que demonstra a arquitetura do Core do Horus.}
\label{fig:diagrama_core}
\end{figure}

A  arquitetura representada acima demonstra de forma geral os integrantes do Toolkit Horus que são o agente inteligente (\textit{Agent}), os dispositivos usados por esse agente (\textit{Device}), o programa de agente (\textit{Brain}), os eventos (\textit{Event}) e a hierarquia de comportamentos (\textit{Behavior}).

Uma vez criado o agente ele precisa de dispositivos (classe \textit{Device}), como lasers ou câmeras, que são necessários para cumprir uma determinada tarefa, ou seja, para atingir o seu objetivo. Além disto, é necessário atribuir a este agente a inteligência (classe \textit{Brain}), isto é, os algoritmos que poderá usar para processar as informações obtidas com seus dispositivos e transformá-las em dados para a fase de pos-processamento.

Para que a aplicação possa usar um programa de agente ela precisa estender a classe \textit{Brain} e implementar o método \textit{run()} dessa classe.

Os comportamentos (classe \textit{Behavior}) são os resposáveis por indicar ao agente o que é necessário ser feito durante o pos-processamento das informações capturadas, isto é, dos eventos que ocorrem e que são compreendidos pelo agente através de seus dispositivos e de seu cérebro.

Entende-se por eventos todos os dados compreendidos pelo agente e que influenciam nas suas decisões, como a detecção de colisões ou a captura e tratamento de imagens no ambiente.

O \textit{Toolkit} Horus oferece algumas classes de comportamentos já definididas que podem ser usadas por qualquer aplicação. São elas:   
\begin{itemize}
\item \textit{NeuralNetworkBehavior}: Disponibiliza métodos para a construção e treinamento de redes neurais na implementação de um comportamento;
\item \textit{TesseractBehavior}: Disponibiliza a funcionalidade de \textit{OCR} da \textit{engine tesseract}, presente no Horus;
\item \textit{MappingBehavior}: Disponibiliza métodos responsáveis pelo processo de navegação, localização e mapeamento de ambientes desconhecidos com base na técnica SLAM.
\end{itemize}

A classe \textit{Environment} representa o ambiente sobre o qual os eventos ocorrem e o agente trabalha. Para que o agente possa obter informações sobre o ambiente é preciso que o \textit{Brain} seja configurado tanto com uma instância da classe \textit{Agent} quanto uma instância da classe \textit{Environment}.

É necessário definir a ordem de execucão quando o cérebro do agente  é configurado com diversos comportamentos. Os comportamentos podem mudar de acordo com as condições identificadas, logo, o cérebro identifica as condições que cada comportamento necessita para ser executado e o ativa quando a sua condição de execução for satisfeita. Porém, há casos em que dois ou mais comportamentos podem ter a sua condição de execução satisfeita. Nesses casos, é necessário definir prioridades de execução sobre os comportamentos lembrando sempre que a maior prioridade deve ser a integridade do agente. A ordem de execução dos comportamentos define a máquina de estados de execução do agente inteligente, que se encaixa com a proposta e a utilização do cérebro no \textit{Toolkit}. 

\subsection{Módulo de Visão}

Módulo onde ficam as funções relativas a visão computacional para agentes inteligentes. Ele leva em consideração o uso de redes neurais para fazer a extração de características e também vários algoritmos de segmentação. Esse módulo tem como principal objetivo o reconhecimento de padrões. Para
reconhecimento de uma placa é necessário identificar algumas características de uma imagem que servirão de padrões de entrada para uma rede neural.

Isso ocorre através de dois processos: Extração de características e reconhecimento de objetos.

\begin{itemize}

\item Extração de características - O objetivo deste processo é abstrair as características de um objeto para, a partir delas, reconhecê-lo usando padrões e usá-los posteriormente pelo método de reconhecimento de objetos.

\item Reconhecimento de objetos - Esse processo utiliza as características que foram obtidas no processo anterior para a partir delas utilizar um classificador e com isso reconhecer o objeto em questão. No caso do Horus foi utilizada como classificador uma rede neural.

\end{itemize}


\subsection{Módulo de Mapeamento}

O módulo responsável pela inteligência do agente, no que diz respeito à localização, movimentação, mapeamento e navegação. 
\begin{itemize}
\item Localização: Entende-se por localização a capacidade do agente localizar-se em um ambiente. 
\item Movimentação: É a capacidade de locomoção em um ambiente.
\item Navegação: O agente se move pelo ambiente mapeado visando um objetivo, com tarefas como otimização de rotas.
\item Mapeamento: É o modo como o agente localiza marcos para identificar a forma do ambiente.

\end{itemize}

\subsection{Localização}

A localização do agente é dada em coordenadas X, Y e Z. Inicialmente o agente conhece apenas a sua posição, que é dada pelas coordenadas (0, 0, 0). Independentemente da posição do agente, no que diz respeito ao ambiente, a inicial será sempre (0, 0, 0). 

Conforme o agente mapeia o ambiente, ele seguirá alterando sua posição a partir da sua posição anterior com base em seu odômetro (dadas as métricas proporcionais).

No \textit{Toolkit} isso funciona da seguinte forma:

\begin{itemize}
\item Obtém-se uma leitura da posição atual.
\item Calcula-se o ângulo de rotação do agente para onde ele navegará.
\item Armazena-se a distância percorrida baseando-se no odômetro.
\item Calcula-se a nova posição com a distância percorrida e o ângulo de rotação.
\end{itemize}

\subsection{Movimentação}

A capacidade que o agente tem de ir de um ponto a outro usando recursos voluntários é o que chamamos do processo de movimentação. A movimentação não é orientada, não possui um objetivo, tratando-se apenas do processo físico de deslocamento, diferentemente da navegação que é planejada e executada obedecendo regras pré-determinadas ou geradas durante a execução do processo.

A movimentação é de total responsabilidade da aplicação.

\subsection{Navegação}
O proceso de navegação é um conjunto de processos de movimentação que seguem uma ou mais regras, por exemplo, ir sempre para o ponto mais distante possível.
É fato que a navegacão tem influência direta no mapeamento, logo um método de navegação eficiente deve ser implementado na aplicação a fim de que o mapeamento seja também eficiente. Em nossa aplicação testamos duas variações de meios de navegação.
Antes de tudo é interessante informar que apesar da navegação ser implementada na aplicação, a escolha do caminho a ser tomado pertence ao Horus e é feita através do método "seeNewWay" cujos passos serão mostrados abaixo.
O primeiro método de navegação desenvolvido baseava-se em fazer com que o agente identificasse o ponto mais distante dentre todas as leituras do laser e então navegasse para aquela direção. Caso houvesse mais do que uma leitura a ser escolhida (por exemplo dois ou mais pontos infinitos identificados) o agente escolheria a primeira leitura entre elas. Essa forma de navegação era muito simples e o agente com frequência retornava para lugares já mapeados.

O segundo método de navegação desenvolvido usa o mesmo pricípio do primeiro, ou seja, a escolha do maior caminho, mas há algumas restrições para essa escolha. Essas restrições compõe uma série de passos (um algoritmo) que foi desenvolvida justamente para melhorar a navegação.

Os passoas abaixo fazem parte do método seeNewWay presente no módulo SLAM desenvolvido:

\begin{itemize}
\item Cada conjunto de leituras dos lasers deve ser armazenado temporariamente em uma estrutura de dados do tipo lista.
\item A lista deve ser dividida em três partes: pontos que estão à esquerda do agente, pontos que estão à direita do agente e o ponto central, ou seja, o laser do meio.
\item Dentre todos os pontos desta leitura, deve-se precisar a quantidade de pontos já mapeados encontrados em cada lado \textendash direito e esquerdo.
\item Escolher o lado que tenha menos pontos já mapeados, caso dê empate então o ponto central é escolhido.
\item Tendo sido escolhido o lado, verificar qual a maior leitura deste lado e navegar para aquela direção.

\end{itemize}



Com este novo método, é possível garantir que o agente sempre preferirá ir para lugares onde hajam menos pontos mapeados.

\subsection{Mapeamento}
O mapeamento do agente baseia-se em um processo chamado tentativas de criação de \textit{\textit{mark points}}. O Horus disponibiliza esse processo através de um método criado em nosso trabalho chamado \textit{tryAMarkPoint}.

\textit{Mark points} (pontos de marcos, ou simplesmente marcos) são circunferências criadas durante a navegação do agente. O algoritmo que gera os \textit{mark points} é uma nova proposta apresentada pelo corrente trabalho para resolver o problema de mapeamento.

Em contrapartida ao SPIKE e ao RANSAC que buscam extrair \textit{landmarks} utilizando-se das colisões dos lasers e esperando que essas colisões atendam a um requisito, no caso do RANSAC espera-se a formação de uma linha, no caso do SPIKE espera-se uma diferença muito grande entre um marco e outro, o processo de criação de \textit{mark points} leva em consideração que todas as colisões dos lasers são \textit{landmarks}, mas nem todos são armazenados.

O landmark escolhido é denominado mark point  e é aquele que não esteja em um ponto por onde o agente já passou.

Essa identificação é feita a partir do método de criação de \textit{mark points} que nesse trabalho é chamado \textit{tryAMarkPoint}.

O algoritmo do \textit{tryAMarkPoint} é o seguinte:
\begin{table}[htb]
\centering         
	\begin{algorithmic}                
		\STATE $\textit{tryAMarkPoint}(tuple posicao\textunderscore robo, float rotacao\textunderscore  robo$)
		\FORALL{$mark\textunderscore point$ $in$ $lista\textunderscore mark\textunderscore point$} 
			\STATE $RESULTADO$ $\leftarrow$ $isPointInCircle( mark\textunderscore point, posicao\textunderscore robo, raio\textunderscore circunferencia$)
			\IF{RESULTADO is \textit{FALSE}} 
				\STATE ADIOCIONAR $\leftarrow$ \textit{VERDADEIRO}
			\ELSE
				\STATE TENTATIVAS $\leftarrow$ TENTATIVAS - 1
			\ENDIF
		\ENDFOR
		\IF{ADICIONAR is \textit{}}
			\STATE  TENTATIVAS $\leftarrow$ TENTATIVAS + 2
			\STATE  Adiciona a posição do robô à lista de \textit{mark points}  
		\ENDIF
		\RETURN $TENTATIVAS$
	\end{algorithmic}
\caption{Algoritmo \textit{tryAMarkPoint}}
\end{table}

NOTA: isPointInCircle é um método criado no módulo matemático responsável por identificar se um determinado ponto está ou não presente em um círculo de raio N. Os \textit{mark points} nada mais são do que círculos criados com raio N e centro na posição do agente no momento da descoberta do mark point.
 
O método retorna o número de tentativas para se criar \textit{mark points}.  A aplicação que usa o método deve verificar a condição de parada do agente utilizando esse número de tentativas.

Este é um conceito de punição e recompensa, ou seja, se o agente encontra um novo mark point \textendash que significa um ponto ainda não explorado \textendash então ele é recompensando com créditos, caso ele passe por um ponto já explorado ele é punido com a perda de créditos. No nosso trabalho, o agente mapeia o ambiente enquanto busca sempre encontrar novos \textit{mark points}, ou seja, busca sempre aumentar os seus créditos e pára de mapear quando esses créditos assumem um valor negativo ou zero, o que significa que não há mais pontos a serem descobertos (mapeamento completo)

\subsection{Outros}

Dentro deste módulo também se enquandram o módulo Graph e suas funcionalidades, que são:
\begin{itemize}
\item \textit{ShortestPath} - Função que retorna o menor caminho de um grafo tendo em vista o algoritmo que for passado, na atual conjultura do projeto apenas um algoritmo foi implementado, o Dijkstra.
\item \textit{ShowAllPaths} - Retorna todos caminhos possíveis até um dedterminado nó independente de ser o mais distante ou o mais próximo.
\item \textit{BuildaGraph} - Como a construção de um grafo necessita da criação correta dee nós e arestas, foi criado este método para construir um grafo e retorná-lo ao final do processo.
\item \textit{Geters} e \textit{Seters} de nós e de arestas do grafo.
\end{itemize}

\subsection{Utils}

Conforme o nome do módulo sugere, ele torna os códigos dos demais módulos livres de reimplementações de coisas comuns a todos os módulos. Tal módulo pode ser usado tanto em conjunto com o toolkit quanto a parte, devido sua usabilidade alta e seu nível de acoplamento baixo.

Algumas funções e métodos presentes no \textit{Utils} do Horus estão dispostas como segue:
\subsubsection{O módulo \textit{"math\textunderscore module"}}
Este módulo possui funções matemáticas usadas pelo Horus. Ele está subdividido em algumas categorias dentre elas, funções trigonométricas e regressão linear.

As funções trigonométricas são:
\begin{itemize}
\item \textbf{getXCateto(self, hypotenuse, angle)} - responsável por encontrar a coordenada X em um plano cartesiano tendo como parâmetros a distância (hipotenusa) até o ponto e o ângulo de rotação atingido para observar aquele ponto.

\item \textbf{getYCateto(self, hypotenuse, angle)} - responsável por encontrar a coordenada Y em um plano cartesiano tendo como parâmetros a distância (hipotenusa) até o ponto e o ângulo de rotação atingido para observar aquele ponto.

\item \textbf{isPointInCircle(self,  center\textunderscore tuple,  point\textunderscore tuple,  radius)} - responsável por definir se um ponto (X, Y) qualquer está ou não contido em um círculo, dado o centro deste e o raio.
\end{itemize}

Além das funções trigonométricas existem também as funções relativas a  regressão linear que é responsável por fazer uma identificação de uma condicional de uma variável y, tendo dados de vários x.
