%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  O Tool Kit Horus
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{O Toolkit Horus}
\label{cap:o_toolkit_horus}

O Horus é um \textit{toolkit}, ou seja, uma coleção de ferramentas (nesse caso módulos) que servem para gerenciar agentes inteligentes, escrito em \textit{Python}. Duas partes estão sendo desenvovdidas a princípio: Módulo de Visão e Módulo de Mapeamento.

No módulo de visão estão os mais variados algoritmos de visão computacional e no módulo de mapeamento trata-se do problema de mapear ambientes a partir de dispositivos de leitura do ambiente e de efetuadores.
\section{Objetivo}

O objetivo do \textit{toolkit} é prover ferramentas necessárias para produção de agentes inteligentes. 

\section{Arquitetura}

Demonstrar a arquitetura utilizada.

\section{Módulos do Horus}

Principais funcionalidades de cada um dos módulos, de forma mais explicada. .
\
\begin{itemize}
\item Core do Horus: Contêm módulos que serão utilizados como suporte para os módulos principais. Sendo assim não necessitam ser utilizados diretamente pelo usuário.
\item Modulo de Visão: Tem por objetivo tratar as principais técnicas de visão computacional de um agente inteligente.
\item Modulo de Mapeamento: O módulo de mapeamento é responsável por gerenciar os tipos de mapeamento bem como os dispositivos utilizados para mapear e navegar no ambiente.
\item Utils: Módulo que contêm funções de suporte para auxiliar no funcionamento dos demais módulos.
\end{itemize}

\subsection{\textit{Core} do Horus}

O Core do Horus é onde se encontram as partes relativas ao agente e seus comportamentos.

\begin{figure}[!htb]
\centering
\begin{center}
    \includegraphics[scale=0.4675,bb=0 0 902 386]{imagens/digramas/diagrama_core.png}
\end{center}
\caption{Diagrama que demonstra a arquitetura do Core do Horus.}
\label{fig:diagrama_core}
\end{figure}

O ambiente 
Agente e dispositivo.
Comportamento: Explicar cada um.
Event: Eventos gerados pelo ambiente que influenciam no comportamento.
Brain


\subsection{Módulo de Visão}

Módulo onde ficam as funções relativas a visão computacional para agentes inteligenes, ele leva em consideração o uso de redes neurais para fazer a extração de característicase também vários algoritmos de segmentação.


\subsection{Módulo de Mapeamento}

O módulo responsável pela inteligência do agente, no que diz respeito à localização, movimentação, mapeamento e navegação. 
\begin{itemize}
\item Localização: Entende-se por localização a capacidade do agente localizar-se em um ambiente. 
\item Movimentação: É a capacidade de locomoção em um ambiente.
\item Navegação: O agente se move pelo ambiente mapeado visando um objetivo, com tarefas como otimização de rotas.
\item Mapeamento: É o modo como o agente localiza marcos para identificar a forma do ambiente.

\end{itemize}

\subsection{Localização}

A localização do agente é dada em coordenadas X, Y e Z. Inicialmente o agente conhece apenas a sua posição, que é dada pelas coordenadas (0, 0, 0). Independentemente da posição do agente, no que diz respeito ao ambiente, a inicial será sempre (0, 0, 0). 

Conforme o agente mapea o ambiente ele seguirá alterando sua posição a partir daque que foi sua posição anterior com base em seu odômetro (dadas as métricas proporcionais).

No \textit{Toolkit} isso funciona da seguinte forma:

\begin{itemize}
\item Obtem-se uma leitura da posição atual.
\item Calcula-se o ângulo de rotação do agente para onde ele navegará.
\item Armazena-se a distância percorrida baseando-se no odômetro.
\item Calcula-se a nova posição com a distância percorrida e o ângulo de rotação.
\end{itemize}

\subsection{Movimentação}

A capacidade que o agente tem de ir de um ponto a outro usando recursos voluntários é o que chamamos do processo de movimentação. A movimentação não é orientada, não possui um objetivo, tratando-se apenas do processo físico de deslocamento, diferentemente da navegação que é planejada e executada obedecendo regras pré-determinadas ou geradas durante a execução do processo.

A movimentação é de total responsabilidade da aplicação.

\subsection{Navegação}
O proceso de navegação é um conjunto de processos de movimentação que seguem uma ou mais regras, por exemplo, ir sempre para o ponto mais distante possível.
É fato que a navegacão tem influência direta no mapeamento, logo um método de navegação eficiente deve ser implementado na aplicação a fim de que o mapeamento seja também eficiente. Em nossa aplicação testamos duas variações de meios de navegação.
Antes de tudo é interessante informar que apesar da navegação ser implementada na aplicação, a escolha do caminho a ser tomado pertence ao Horus e é feita através do método "seeNewWay" cujos passos serão mostrados abaixo.
O primeiro método de navegação desenvolvido baseava-se em fazer com que o agente identificasse o ponto mais distante dentre todas as leituras do laser e então navegasse para aquela direção. Caso houvesse mais do que uma leitura a ser escolhida (por exemplo dois ou mais pontos infinitos identificados) o agente escolheria a primeira leitura entre elas. Essa forma de navegação era muito simples e o agente com frequência retornava para lugares já mapeados.

O segundo método de navegação desenvolvido usa o mesmo pricípio do primeiro, ou seja, a escolha do maior caminho, mas há algumas restrições para essa escolha. Essas restrições compõe uma série de passos (um algoritmo) que foi desenvolvida justamente para melhorar a navegação.

Os passoas abaixo fazem parte do método seeNewWay presente no módulo SLAM desenvolvido:

\begin{itemize}
\item Cada conjunto de leituras dos lasers deve ser armazenado temporariamente em uma estrutura de dados do tipo lista.
\item A lista deve ser dividida em três partes: pontos que estão à esquerda do agente, pontos que estão à direita do agente e o ponto central, ou seja, o laser do meio.
\item Dentre todos os pontos desta leitura, deve-se precisar a quantidade de pontos já mapeados encontrados em cada lado \textendash direito e esquerdo.
\item Escolher o lado que tenha menos pontos já mapeados, caso dê empate então o ponto central é escolhido.
\item Tendo sido escolhido o lado, verificar qual a maior leitura deste lado e navegar para aquela direção.

\end{itemize}



Com este novo método, é possível garantir que o agente sempre preferirá ir para lugares onde hajam menos pontos mapeados.

\subsection{Mapeamento}
O mapeamento do agente baseia-se em um processo chamado tentativas de criação de mark points. O Horus disponibiliza esse processo através de um método criado em nosso trabalho chamado tryAMarkPoint.

Mark Points (pontos de marcos, ou simplesmente marcos) são circunferências criadas durante a navegação do agente. O algoritmo que gera os mark points é uma nova proposta apresentada pelo corrente trabalho para resolver o problema de mapeamento.

Em contrapartida ao SPIKE e ao RANSAC que buscam extrair landmarks utilizando-se das colisões dos lasers e esperando que essas colisões atendam a um requisito, no caso do RANSAC espera-se a formação de uma linha, no caso do SPIKE espera-se uma diferença muito grande entre um marco e outro, o processo de criação de mark points leva em consideração que todas as colisões dos lasers são landmarks, mas nem todos são armazenados.

O landmark escolhido é denominado mark point  e é aquele que não esteja em um ponto por onde o agente já passou.

Essa identificação é feita a partir do método de criação de mark points que nesse trabalho é chamado tryAMarkPoint [colocar referencia para o apêndice].

O algoritmo do tryAMarkPoint é o seguinte:
\begin{table}[htb]
\centering         
	\begin{algorithmic}                
		\STATE $tryAMarkPoint(tuple posicao\textunderscore robo, float rotacao\textunderscore  robo$)
		\FORALL{$cada$ $mark\textunderscore point$ $em$ $lista\textunderscore mark\textunderscore poin$} 
			\STATE $RESULTADO$ $\leftarrow$ $isPointInCircle( mark\textunderscore point, posicao\textunderscore robo, raio\textunderscore circunferencia$)
			\IF{RESULTADO é \textit{FALSO}} 
				\STATE ADIOCIONAR $\leftarrow$ \textit{VERDADEIRO}
			\ELSE
				\STATE TENTATIVAS $\leftarrow$ TENTATIVAS - 1
			\ENDIF
		\ENDFOR
		\IF{ADICIONAR é \textit{VERDADEIRO}}
			\STATE  TENTATIVAS $\leftarrow$ TENTATIVAS + 2
			\STATE  Adiciona a posição do robô à lista de Mark Points  
		\ENDIF
		\RETURN $TENTATIVAS$
	\end{algorithmic}
\caption{Algoritmo tryAMarkPoint}
\end{table}

NOTA: isPointInCircle é um método criado no módulo matemático responsável por identificar se um determinado ponto está ou não presente em um círculo de raio N. Os mark points nada mais são do que círculos criados com raio N e centro na posição do agente no momento da descoberta do mark point.
 
O método retorna o número de tentativas para se criar mark points.  A aplicação que usa o método deve verificar a condição de parada do agente utilizando esse número de tentativas.

Este é um conceito de punição e recompensa, ou seja, se o agente encontra um novo mark point \textendash que significa um ponto ainda não explorado \textendash então ele é recompensando com créditos, caso ele passe por um ponto já explorado ele é punido com a perda de créditos. No nosso trabalho, o agente mapeia o ambiente enquanto busca sempre encontrar novos mark points, ou seja, busca sempre aumentar os seus créditos e pára de mapear quando esses créditos assumem um valor negativo ou zero, o que significa que não há mais pontos a serem descobertos (mapeamento completo)

\subsection{Outros}

Dentro deste módulo também se enquandram o módulo Graph e suas funcionalidades, que são:
\begin{itemize}
\item \textit{ShortestPath} - Função que retorna o menor caminho de um grafo tendo em vista o algoritmo que for passado, na atual conjultura do projeto apenas um algoritmo foi implementado, o Dijkstra.
\item \textit{ShowAllPaths} - Retorna todos caminhos possíveis até um dedterminado nó independente de ser o mais distante ou o mais próximo.
\item \textit{BuildaGraph} - Como a construção de um grafo necessita da criação correta dee nós e arestas, foi criado este método para construir um grafo e retorná-lo ao final do processo.
\item \textit{Geters} e \textit{Seters} de nós e de arestas do grafo.
\end{itemize}

\subsection{Utils}

Conforme o nome do módulo sugere, ele torna os códigos dos demais módulos livres reimplementações de coisas comuns a todos os módulos. Tal módulo pode ser usado tanto em conjunto com o toolkit quanto a parte, devido sua usabilidade alta e seu nível de acoplamento baixo.

Algumas funções e métodos presentes no \textit{Utils} do Horus estão dispostas como segue:
\subsubsection{O módulo \textit{"math\textunderscore module"}}
Este módulo possui funções matemáticas usadas pelo Horus. Ele está subdividido em algumas categorias dentre elas, funções trigonométricas e regressão linear.

As funções trigonométricas são:
\begin{itemize}
\item \textbf{getXCateto(self, hypotenuse, angle)} - responsável por encontrar a coordenada X em um plano cartesiano tendo como parâmetros a distância (hipotenusa) até o ponto e o ângulo de rotação atingido para observar aquele ponto.

\item \textbf{getYCateto(self, hypotenuse, angle)} - responsável por encontrar a coordenada Y em um plano cartesiano tendo como parâmetros a distância (hipotenusa) até o ponto e o ângulo de rotação atingido para observar aquele ponto.

\item \textbf{isPointInCircle(self,  center\textunderscore tuple,  point\textunderscore tuple,  radius)} - responsável por definir se um ponto (X, Y) qualquer está ou não contido em um círculo, dado o centro deste e o raio.
\end{itemize}

Além das funções trigonométricas existem também as funções relativas a  Regressão linear que é responsável por fazer uma identificação de uma condicional de uma variável y, tendo dados de vários x.
